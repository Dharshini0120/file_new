import React, { useState, useEffect, useRef } from 'react';
import { Handle, Position } from 'reactflow';
import { Box, IconButton } from '@mui/material';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import TemplateEditQuestionModal from './TemplateEditQuestionModal';

interface OptionData {
    text: string;
    score?: number | string;
    referralText?: string;
}

interface QuestionNodeData {
    question: string;
    questionType: 'text-input' | 'multiple-choice' | 'radio' | 'checkbox' | 'yes-no' | 'select';
    options: string[] | OptionData[];
    isRequired: boolean;
    onUpdate: (id: string, newData: any) => void;
    onDelete: (id: string) => void;
    onUpdateEdgeLabels?: (nodeId: string, newOptions: string[]) => void;
    isPreview?: boolean; // Add flag to indicate preview mode
    optionsData?: OptionData[]; // Optional field for full option data
}

interface QuestionNodeProps {
    data: QuestionNodeData;
    id: string;
}

const TemplateQuestionNode: React.FC<QuestionNodeProps> = ({ data, id }) => {
    const [showEditModal, setShowEditModal] = useState(!data.question);
    const [nodePosition, setNodePosition] = useState({ x: 0, y: 0 });
    const nodeRef = useRef<HTMLDivElement>(null);
    const { question, questionType, options, isRequired, isPreview } = data;

    // Check if there's optionsData field with full option information
    const optionsData = data.optionsData;

    // Debug logging for data structure
    console.log('🔍 TemplateQuestionNode data:', { id, question, questionType, options, isRequired });
    console.log('🔍 Full data object:', data);
    console.log('🔍 Options type:', typeof options, Array.isArray(options));
    console.log('🔍 Options content:', options);
    console.log('🔍 OptionsData:', optionsData);
    console.log('🔍 Data keys:', Object.keys(data));
    console.log('🔍 Options length:', options?.length);
    if (options && Array.isArray(options) && options.length > 0) {
        console.log('🔍 First option:', options[0]);
        console.log('🔍 First option type:', typeof options[0]);
        if (typeof options[0] === 'object' && options[0] !== null) {
            console.log('🔍 First option keys:', Object.keys(options[0]));
        }
    }

    // Get node position for modal placement
    useEffect(() => {
        if (nodeRef.current && showEditModal) {
            const rect = nodeRef.current.getBoundingClientRect();
            const reactFlowBounds = document.querySelector('.react-flow')?.getBoundingClientRect();

            if (reactFlowBounds) {
                setNodePosition({
                    x: rect.right - reactFlowBounds.left + 30, // Consistent 30px gap from right edge
                    y: rect.top - reactFlowBounds.top - 10 // Consistent 10px above the node
                });
            }
        }
    }, [showEditModal]);

    // Watch for data changes to ensure modal gets latest data from Live Preview
    useEffect(() => {
        console.log('🔄 TemplateQuestionNode data updated:', { 
            question, 
            questionType, 
            options, 
            optionsData, 
            isRequired 
        });
        
        // If modal is open and data has changed significantly, force it to re-render
        // This ensures the modal shows the latest data from Live Preview
        if (showEditModal) {
            console.log('🔄 Modal is open, checking if data changed significantly');
            
            // Check if the current modal data is different from the latest node data
            const currentModalData = {
                question: question,
                optionsData: optionsData
            };
            
            const latestNodeData = {
                question: data.question,
                optionsData: data.optionsData
            };
            
            const dataChanged = JSON.stringify(currentModalData) !== JSON.stringify(latestNodeData);
            
            if (dataChanged) {
                console.log('🔄 Data changed significantly, modal will re-render with new key');
            }
        }
    }, [question, questionType, options, optionsData, isRequired, showEditModal, data.question, data.optionsData]);

    const getQuestionTypeLabel = () => {
        switch (questionType) {
            case 'text-input': return 'TEXT INPUT';
            case 'multiple-choice': return 'MULTIPLE CHOICE';
            case 'radio': return 'RADIO';
            case 'checkbox': return 'CHECKBOX';
            case 'yes-no': return 'YES/NO';
            case 'select': return 'SELECT';
            default: return 'QUESTION';
        }
    };

    const handleSave = (newData: any) => {
        console.log('💾 TemplateQuestionNode received save data:', newData);
        
        // Ensure we save both the legacy options format and the full optionsData
        // But preserve the original options array if it contains valid strings
        const originalOptions = Array.isArray(data.options) ? data.options : [];
        const hasValidOptions = originalOptions.length > 0 && typeof originalOptions[0] === 'string';
        
        const dataToSave = {
            ...newData,
            // Preserve the original options array if it contains valid strings
            // Otherwise use the new options from the modal
            options: hasValidOptions ? originalOptions : (newData.options || []),
            // Save the full optionsData for future use
            optionsData: newData.optionsData || []
        };

        console.log('💾 Original options:', originalOptions);
        console.log('💾 Has valid options:', hasValidOptions);
        console.log('💾 Saving data to node:', dataToSave);
        console.log('💾 Options to save:', dataToSave.options);
        console.log('💾 OptionsData to save:', dataToSave.optionsData);

        // Update the node data first
        data.onUpdate(id, dataToSave);

        // Update connected edge labels if options changed
        if (newData.options && data.onUpdateEdgeLabels) {
            data.onUpdateEdgeLabels(id, newData.options);
        }

        setShowEditModal(false);
    };

    const handleDelete = () => {
        data.onDelete(id);
    };

    const handleEdit = () => {
        console.log('🔄 Opening edit modal with latest data:', {
            nodeData: data,
            localData: { question, questionType, options, optionsData, isRequired }
        });
        setShowEditModal(true);
    };

    const updateConnectedEdgeLabels = (nodeId: string, newOptions: string[]) => {
        // This function should be passed from the parent component
        if (data.onUpdateEdgeLabels) {
            data.onUpdateEdgeLabels(nodeId, newOptions);
        }
    };

    return (
        <>
            <Box
                ref={nodeRef}
                sx={{
                    background: '#f0f2f3',
                    border: '2px solid #4baaf4',
                    borderRadius: '12px',
                    minWidth: '280px',
                    maxWidth: '350px',
                    boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
                    overflow: 'visible',
                    position: 'relative'
                }}
            >
                {/* Input Handle */}
                <Handle
                    type="target"
                    position={Position.Top}
                    style={{
                        background: '#4baaf4',
                        width: '12px',
                        height: '12px',
                        border: '2px solid white',
                        borderRadius: '50%',
                        top: '-18px',
                        zIndex: 100,
                        boxShadow: '0 2px 4px rgba(0,0,0,0.3)'
                    }}
                />

                {/* Header */}
                <Box sx={{
                    background: '#4baaf4',
                    color: 'white',
                    padding: '12px 15px',
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    borderRadius: '10px 10px 0 0'
                }}>
                    <Box sx={{
                        fontSize: '12px',
                        fontWeight: '700',
                        textTransform: 'uppercase',
                        letterSpacing: '0.5px'
                    }}>
                        {getQuestionTypeLabel()}
                        {isRequired && <span style={{ color: '#ff4444', marginLeft: '4px', fontWeight: 'bold' }}>*</span>}
                    </Box>
                    {/* Only show edit/delete buttons when not in preview mode */}
                    {!isPreview && (
                        <Box sx={{ display: 'flex', gap: '4px' }}>
                            <IconButton
                                size="small"
                                onClick={handleEdit}
                                sx={{
                                    color: 'white',
                                    background: 'rgba(255,255,255,0.2)',
                                    width: '24px',
                                    height: '24px',
                                    '&:hover': { background: 'rgba(255,255,255,0.3)' }
                                }}
                            >
                                <EditIcon sx={{ fontSize: '14px' }} />
                            </IconButton>
                            <IconButton
                                size="small"
                                onClick={handleDelete}
                                sx={{
                                    color: 'white',
                                    background: 'rgba(255,255,255,0.2)',
                                    width: '24px',
                                    height: '24px',
                                    '&:hover': { background: 'rgba(255,255,255,0.3)' }
                                }}
                            >
                                <DeleteIcon sx={{ fontSize: '14px' }} />
                            </IconButton>
                        </Box>
                    )}
                </Box>

                {/* Content */}
                <Box sx={{ padding: '15px' }}>
                    <Box sx={{
                        fontSize: '16px',
                        fontWeight: '600',
                        color: '#4baaf4',
                        marginBottom: '8px',
                        lineHeight: '1.3'
                    }}>
                        {question || 'Untitled Question'}
                    </Box>

                    {/* Show options for applicable question types */}
                    {['multiple-choice', 'checkbox', 'radio', 'select'].includes(questionType) && options && (
                        <Box sx={{ fontSize: '13px', color: '#666' }}>
                            <Box sx={{ fontWeight: '600', marginBottom: '4px' }}>Options:</Box>
                            <Box component="ul" sx={{ margin: '0', paddingLeft: '15px' }}>
                                {options.map((option, index) => {
                                    // Handle both string and object options
                                    let optionText = '';
                                    let optionScore = undefined;
                                    
                                    if (typeof option === 'string') {
                                        optionText = option;
                                    } else if (typeof option === 'object' && option !== null) {
                                        optionText = option.text || `Enter option text here`;
                                        optionScore = option.score;
                                    } else {
                                        optionText = `Enter option text here`;
                                    }

                                    return (
                                        <Box component="li" key={index} sx={{ marginBottom: '2px', fontWeight: '500' }}>
                                            {optionText}
                                            {optionScore !== undefined && optionScore !== '' && (
                                                <span style={{ color: '#059669', fontSize: '11px', marginLeft: '8px' }}>
                                                    (Score: {optionScore})
                                                </span>
                                            )}
                                        </Box>
                                    );
                                })}
                            </Box>
                        </Box>
                    )}

                    {questionType === 'yes-no' && (
                        <Box sx={{ fontSize: '13px', color: '#666' }}>
                            <Box sx={{ fontWeight: '600' }}>Yes / No options</Box>
                        </Box>
                    )}

                    {questionType === 'text-input' && (
                        <Box sx={{ fontSize: '13px', color: '#666' }}>
                            <Box sx={{ fontWeight: '600' }}>Text input field</Box>
                        </Box>
                    )}
                </Box>

                {/* Output Handles */}
                {questionType === 'text-input' && (
                    <Handle
                        type="source"
                        position={Position.Right}
                        id="text-output"
                        style={{
                            background: '#4baaf4',
                            width: '12px',
                            height: '12px',
                            border: '2px solid white',
                            borderRadius: '50%',
                            right: '-6px',
                            top: '85px',
                            zIndex: 100,
                            boxShadow: '0 2px 4px rgba(0,0,0,0.3)'
                        }}
                    />
                )}

                {questionType === 'yes-no' && (
                    <>
                        <Handle
                            type="source"
                            position={Position.Right}
                            id="yes"
                            style={{
                                background: '#4baaf4',
                                width: '12px',
                                height: '12px',
                                border: '2px solid white',
                                borderRadius: '50%',
                                right: '-6px',
                                top: '85px',
                                zIndex: 100,
                                boxShadow: '0 2px 4px rgba(0,0,0,0.3)'
                            }}
                        />
                        <Handle
                            type="source"
                            position={Position.Right}
                            id="no"
                            style={{
                                background: '#4baaf4',
                                width: '12px',
                                height: '12px',
                                border: '2px solid white',
                                borderRadius: '50%',
                                right: '-6px',
                                top: '105px',
                                zIndex: 100,
                                boxShadow: '0 2px 4px rgba(0,0,0,0.3)'
                            }}
                        />
                    </>
                )}

                {/* Individual option handles for multiple-choice, radio, and select */}
                {['multiple-choice', 'radio', 'select'].includes(questionType) && options &&
                    options.map((option, index) => (
                        <Handle
                            key={`option-${index}`}
                            type="source"
                            position={Position.Right}
                            id={`option-${index}`}
                            style={{
                                background: '#4baaf4',
                                width: '12px',
                                height: '12px',
                                border: '2px solid white',
                                borderRadius: '50%',
                                right: '-6px',
                                top: `${85 + (index * 20)}px`,
                                zIndex: 100,
                                boxShadow: '0 2px 4px rgba(0,0,0,0.3)'
                            }}
                        />
                    ))
                }

                {/* Checkbox handles - individual options + All Selected */}
                {questionType === 'checkbox' && options && (
                    <>
                        {/* Individual option handles */}
                        {options.map((option, index) => (
                            <Handle
                                key={`option-${index}`}
                                type="source"
                                position={Position.Right}
                                id={`option-${index}`}
                                style={{
                                    background: '#4baaf4',
                                    width: '12px',
                                    height: '12px',
                                    border: '2px solid white',
                                    borderRadius: '50%',
                                    right: '-6px',
                                    top: `${85 + (index * 18)}px`,
                                    zIndex: 100,
                                    boxShadow: '0 2px 4px rgba(0,0,0,0.3)'
                                }}
                            />
                        ))}

                        {/* All Selected handle */}
                        {options.length >= 2 && (
                            <Handle
                                type="source"
                                position={Position.Right}
                                id="multi-all"
                                style={{
                                    background: '#4caf50',
                                    width: '14px',
                                    height: '14px',
                                    border: '2px solid white',
                                    borderRadius: '50%',
                                    right: '-7px',
                                    top: `${85 + options.length * 18 + 10}px`,
                                    zIndex: 100,
                                    boxShadow: '0 2px 4px rgba(0,0,0,0.3)'
                                }}
                            />
                        )}
                    </>
                )}
            </Box>

            {/* Edit Modal positioned relative to node */}
            {showEditModal && (() => {
                // ALWAYS prioritize optionsData from Live Preview updates
                // This ensures the modal shows the latest data from Live Preview
                let finalOptions;
                if (data.optionsData && Array.isArray(data.optionsData) && data.optionsData.length > 0) {
                    console.log('🎯 Using LIVE PREVIEW optionsData:', data.optionsData);
                    finalOptions = data.optionsData;
                } else if (optionsData && Array.isArray(optionsData) && optionsData.length > 0) {
                    console.log('🎯 Using local optionsData:', optionsData);
                    finalOptions = optionsData;
                } else if (options && Array.isArray(options) && options.length > 0) {
                    console.log('🔄 Reconstructing options from options array:', options);
                    
                    // Check if options are already OptionData objects with text
                    const firstOption = options[0];
                    if (typeof firstOption === 'object' && firstOption !== null && 'text' in firstOption && firstOption.text !== undefined && firstOption.text !== '') {
                        // Options are already in OptionData format with valid text
                        console.log('🎯 Options are already OptionData format with text:', options);
                        finalOptions = options as OptionData[];
                    } else if (typeof firstOption === 'string') {
                        // Options are strings - this is the correct case
                        console.log('🎯 Options are strings, converting to OptionData:', options);
                        finalOptions = options.map(opt => ({ 
                            text: opt, 
                            score: undefined, 
                            referralText: '' 
                        }));
                    } else if (typeof firstOption === 'object' && firstOption !== null) {
                        // Options are objects but missing text property - this is corrupted data
                        // We need to reconstruct from the original options array or use defaults
                        console.log('⚠️ Options are corrupted objects missing text, attempting to reconstruct');
                        
                        // Try to find any existing optionsData that might have the text
                        if (data.optionsData && Array.isArray(data.optionsData)) {
                            console.log('🎯 Found existing optionsData to use:', data.optionsData);
                            finalOptions = data.optionsData;
                        } else {
                            // Fallback to default options since we can't recover the text
                            console.log('⚠️ No recoverable text found, using default options');
                            finalOptions = [
                                { text: 'Enter option text here', score: undefined, referralText: '' },
                                { text: 'Enter option text here', score: undefined, referralText: '' }
                            ];
                        }
                    } else {
                        // Fallback to defaults
                        finalOptions = [
                            { text: 'Enter option text here', score: undefined, referralText: '' },
                            { text: 'Enter option text here', score: undefined, referralText: '' }
                        ];
                    }
                } else {
                    // No options, use defaults
                    finalOptions = [
                        { text: 'Enter option text here', score: undefined, referralText: '' },
                        { text: 'Enter option text here', score: undefined, referralText: '' }
                    ];
                }

                // Always use the latest data from the node for the modal
                const questionData = {
                    question: data.question || question,
                    questionType: data.questionType || questionType,
                    options: finalOptions,
                    isRequired: data.isRequired !== undefined ? data.isRequired : isRequired,
                    optionsData: data.optionsData || finalOptions // Use node's optionsData if available, otherwise use converted options
                };

                console.log('🚀 Final questionData being passed to modal:', {
                    question: questionData.question,
                    questionType: questionData.questionType,
                    options: questionData.options,
                    optionsData: questionData.optionsData,
                    isRequired: questionData.isRequired
                });

                console.log('🚀 Passing questionData to modal:', questionData);
                console.log('🚀 finalOptions details:', finalOptions.map((opt, idx) => ({
                    index: idx,
                    text: opt.text,
                    score: opt.score,
                    referralText: opt.referralText
                })));
                console.log('🚀 Node data for comparison:', {
                    nodeQuestion: data.question,
                    nodeQuestionType: data.questionType,
                    nodeOptions: data.options,
                    nodeOptionsData: data.optionsData,
                    nodeIsRequired: data.isRequired
                });

                // Create a more specific key that changes when the actual data changes
                const modalKey = `${id}-${data.question}-${JSON.stringify(data.optionsData)}-${data.isRequired}`;
                
                return (
                    <TemplateEditQuestionModal
                        key={modalKey} // Force re-render when actual node data changes
                        questionData={questionData}
                        onSave={handleSave}
                        onCancel={() => setShowEditModal(false)}
                        isNewQuestion={false}
                        nodePosition={nodePosition}
                    />
                );
            })()}
        </>
    );
};

export default TemplateQuestionNode;
















